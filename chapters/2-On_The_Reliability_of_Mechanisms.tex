Being a programmer by trade, programs are what I am talking about
and the true subject of this section really is the reliability of
programs. That, nevertheless, I have mentioned ``mechanism'' in its
title is because I regard programs as specific instances of
mechanisms, and that I wanted to express, at least once, my strong
feeling that many of my considerations concerning software are,
mutatis mutandis, just as relevant for hardware design.

Present-day computers are amazing pieces of equipment, but most
amazing of all are the uncertain grounds on account of which we
attach any validity to their output. It starts already with our
belief that the hardware functions properly.

Let us restrict, for a moment, our attention to the hardware and
let us wonder to what extent one can convince oneself of its being
properly constructed. Some years ago a machine was installed on the
premises of my University; in its documentation it was stated that
it contained, among many other things, circuitry for the fixed-point
multiplication of two 27-bit integers. A legitimate question seems to
be: ``Is this multiplier correct, is it performing according to the
specifications?''.

The naive answer to this is: ``Well, the number of different
multiplications this multiplier is claimed to perform correctly is
finite, viz. $2^{54}$, so let us try them all.'' But, reasonable as
this answer may seem, it is not, for although a single multiplication
took only some tens of microseconds, the total time needed for this
finite set of multiplications would add up to more than 10,000 years!
We must conclude that exhaustive testing, even of a single component
such as a multiplier, is entirely out of the question. (Testing a
complete computer on the same basis would imply the established
correct processing of all possible programs!)

A first consequence of the 10,000 years is that during its life-time
the multiplier will be asked to perform only a negligible fraction of
the vast number of all possible multiplications it could do: practically
none of them! Funnily enough, we still require that it would do any
multiplication correctly when ordered to do so. The reason underlying
this fantastic quality requirement is that we do not know in advance,
which are the negligibly few multiplications it will be asked to perform.
In our reasoning about our programs we talk about ``the product'' and have
abstracted from the specific values of the factors: we do not know them,
we do not wish to know them, it is not our business to know them, it is
our business not to know them! Our wish to think in terms of the concept
``the product'', abstracted from the specific instances occurring in a
computation is granted, but the price paid for this is precisely the
reliability requirement that \underline{any} multiplication of the vast
set will be performed correctly. So much for the justification of our
desire for a correct multiplier.

But how is the correctness established in a convincing manner? As long as
the multiplier is considered as a black box, the only thing we can do is
``testing by sampling'', i,e. offering to the multiplier a feasible amount
of factor pairs and checking the result. But in view of the 10,000 years,
it is clear that we can only test a negligible fraction of the possible
multiplications. Whole classes of in some sense ``critical''
multiplications may remain untested and in view of the reliability justly
desired, our quality control is still most unsatisfactory. Therefore
it is not done that way.

The straightforward conclusion is the following: a convincing demonstration
of correctness being impossible as long as the mechanism is regarded as a
black box, our only hope lies in not regarding the mechanism as a black box.
I shall call this ``taking the structure of the mechanism into account''.

From now onwards the type of mechanisms we are going to deal with are programs.
(In many respects, programs are mechanisms much easier to deal with than
circuitry. Which is really an analogue device and subject to wear and tear.)
And also with programs it is fairly hopeless to establish the correctness
beyond even the mildest doubt by testing without taking their structure into
account. In other words, we remark that the extent to which the program
correctness can be established is not purely a function of the program's
external specifications and behaviour but depends critically upon its internal
structure.

Recalling that our true concern is with really large programs  we observe as
an aside that the size itself requires a high confidence level for the
individual program components. If the chance of correctness of an individual
component equals $p$, the chance of correctness of a whole program, composed of
$N$ such components, is something like \[P = p^N.\] As $N$ will be very large,
$p$ should be very, very close to $1$ if we desire $P$ to differ significantly
from zero!

When we now take the position that it is not only the programmer's task to
produce a correct program but also to demonstrate its correctness in a
convincing manner, then the above remarks have a profound influence on the
programmer's activity: the object he has to produce must be usefully structured.

The remaining part of this monograph will mainly be an exploration of what
program structure can be used to good advantage. In what follows it will become
apparent that program correctness is not my only concern, program adaptability
or manageability will be another. This stress on program manageability is my
deliberate choice, a choice that, therefore, I should like to justify.

While in the past the growth in power of the generally available equipment
has mitigated the urgency of the efficiency requirements, this very same growth
has created its new difficulties. Once one has a powerful machine at one's
disposal one tries to use it and the size of the problems one tackles adjusts
itself to the scope of the equipment: no one thinks about programming an
algorithm that would take twenty years to execute. With processing power
increased by a factor of a thousand over the last ten to fifteen years, Man
has become considerably more ambitious in selecting problems that now should be
``technically feasible''. Size, complexity and sophistication of programs one
should like to make have exploded and over the past years it has become
patently clear that on the whole our programming ability has not kept pace
with these exploding demands made on it.

The power of available equipment will continue to grow: we can expect
manufacturers to develop still faster machines and even without that development
we shall witness that the type of machine that is presently considered as
exceptionally fast will become more and more common. The things we should like
to do with these machines will grow in proportion and it is on this
extrapolation that I have formed my picture of the programmer's task.

My conclusion is that it is becoming most urgent to stop to consider
programming primarily as the minimization of a cost/performance ratio. We should
recognize that already now programming is much more an intellectual challenge:
the art of programming is the art of organizing complexity, of mastering
multitude and avoiding its bastard chaos as effectively as possible.

My refusal to regard efficiency considerations as the programmer's prime
concern is not meant to imply that I disregard them. On the contrary, efficiency
considerations are recognized as one of the main incentives to modifying a
logically correct program. My point, however, is that we can only afford to
optimize (Whatever that may be) provided that the program remains sufficiently
manageable.

Let me end this section with a final aside on the significance of computers.
Computers are extremely flexible and powerful tools and many feel that their
application is changing the face of the earth. I would venture the opinion that
as long as we regard them primarily as tools, we might grossly underestimate
their significance. Their influence as tools might turn out to be but a ripple
on the surface of our culture, whereas I expect them to have a much more
profound influence in their capacity of intellectual challenge!

\vspace{72pt}
\noindent Corollary of the first part of this section:\\
\indent Program testing can be used to show the presence of bugs, but never to show
their absence!
